{"ast":null,"code":"import { Tracer } from 'core/tracers';\nimport { distance } from 'common/util';\nimport { GraphRenderer } from 'core/renderers';\nclass GraphTracer extends Tracer {\n  getRendererClass() {\n    return GraphRenderer;\n  }\n  init() {\n    super.init();\n    this.dimensions = {\n      baseWidth: 320,\n      baseHeight: 320,\n      padding: 32,\n      nodeRadius: 12,\n      arrowGap: 4,\n      nodeWeightGap: 4,\n      edgeWeightGap: 4\n    };\n    this.isDirected = true;\n    this.isWeighted = false;\n    this.callLayout = {\n      method: this.layoutCircle,\n      args: []\n    };\n    this.logTracer = null;\n  }\n  set(array2d = []) {\n    this.nodes = [];\n    this.edges = [];\n    for (let i = 0; i < array2d.length; i++) {\n      this.addNode(i);\n      for (let j = 0; j < array2d.length; j++) {\n        const value = array2d[i][j];\n        if (value) {\n          this.addEdge(i, j, this.isWeighted ? value : null);\n        }\n      }\n    }\n    this.layout();\n    super.set();\n  }\n  directed(isDirected = true) {\n    this.isDirected = isDirected;\n  }\n  weighted(isWeighted = true) {\n    this.isWeighted = isWeighted;\n  }\n  addNode(id, weight = null, x = 0, y = 0, visitedCount = 0, selectedCount = 0) {\n    if (this.findNode(id)) return;\n    this.nodes.push({\n      id,\n      weight,\n      x,\n      y,\n      visitedCount,\n      selectedCount\n    });\n    this.layout();\n  }\n  updateNode(id, weight, x, y, visitedCount, selectedCount) {\n    const node = this.findNode(id);\n    const update = {\n      weight,\n      x,\n      y,\n      visitedCount,\n      selectedCount\n    };\n    Object.keys(update).forEach(key => {\n      if (update[key] === undefined) delete update[key];\n    });\n    Object.assign(node, update);\n  }\n  removeNode(id) {\n    const node = this.findNode(id);\n    if (!node) return;\n    const index = this.nodes.indexOf(node);\n    this.nodes.splice(index, 1);\n    this.layout();\n  }\n  addEdge(source, target, weight = null, visitedCount = 0, selectedCount = 0) {\n    if (this.findEdge(source, target)) return;\n    this.edges.push({\n      source,\n      target,\n      weight,\n      visitedCount,\n      selectedCount\n    });\n    this.layout();\n  }\n  updateEdge(source, target, weight, visitedCount, selectedCount) {\n    const edge = this.findEdge(source, target);\n    const update = {\n      weight,\n      visitedCount,\n      selectedCount\n    };\n    Object.keys(update).forEach(key => {\n      if (update[key] === undefined) delete update[key];\n    });\n    Object.assign(edge, update);\n  }\n  removeEdge(source, target) {\n    const edge = this.findEdge(source, target);\n    if (!edge) return;\n    const index = this.edges.indexOf(edge);\n    this.edges.splice(index, 1);\n    this.layout();\n  }\n  findNode(id) {\n    return this.nodes.find(node => node.id === id);\n  }\n  findEdge(source, target, isDirected = this.isDirected) {\n    if (isDirected) {\n      return this.edges.find(edge => edge.source === source && edge.target === target);\n    } else {\n      return this.edges.find(edge => edge.source === source && edge.target === target || edge.source === target && edge.target === source);\n    }\n  }\n  findLinkedEdges(source, isDirected = this.isDirected) {\n    if (isDirected) {\n      return this.edges.filter(edge => edge.source === source);\n    } else {\n      return this.edges.filter(edge => edge.source === source || edge.target === source);\n    }\n  }\n  findLinkedNodeIds(source, isDirected = this.isDirected) {\n    const edges = this.findLinkedEdges(source, isDirected);\n    return edges.map(edge => edge.source === source ? edge.target : edge.source);\n  }\n  findLinkedNodes(source, isDirected = this.isDirected) {\n    const ids = this.findLinkedNodeIds(source, isDirected);\n    return ids.map(id => this.findNode(id));\n  }\n  getRect() {\n    const {\n      baseWidth,\n      baseHeight,\n      padding\n    } = this.dimensions;\n    const left = -baseWidth / 2 + padding;\n    const top = -baseHeight / 2 + padding;\n    const right = baseWidth / 2 - padding;\n    const bottom = baseHeight / 2 - padding;\n    const width = right - left;\n    const height = bottom - top;\n    return {\n      left,\n      top,\n      right,\n      bottom,\n      width,\n      height\n    };\n  }\n  layout() {\n    const {\n      method,\n      args\n    } = this.callLayout;\n    method.apply(this, args);\n  }\n  layoutCircle() {\n    this.callLayout = {\n      method: this.layoutCircle,\n      args: arguments\n    };\n    const rect = this.getRect();\n    const unitAngle = 2 * Math.PI / this.nodes.length;\n    let angle = -Math.PI / 2;\n    for (const node of this.nodes) {\n      const x = Math.cos(angle) * rect.width / 2;\n      const y = Math.sin(angle) * rect.height / 2;\n      node.x = x;\n      node.y = y;\n      angle += unitAngle;\n    }\n  }\n  layoutTree(root = 0, sorted = false) {\n    this.callLayout = {\n      method: this.layoutTree,\n      args: arguments\n    };\n    const rect = this.getRect();\n    if (this.nodes.length === 1) {\n      const [node] = this.nodes;\n      node.x = (rect.left + rect.right) / 2;\n      node.y = (rect.top + rect.bottom) / 2;\n      return;\n    }\n    let maxDepth = 0;\n    const leafCounts = {};\n    let marked = {};\n    const recursiveAnalyze = (id, depth) => {\n      marked[id] = true;\n      leafCounts[id] = 0;\n      if (maxDepth < depth) maxDepth = depth;\n      const linkedNodeIds = this.findLinkedNodeIds(id, false);\n      for (const linkedNodeId of linkedNodeIds) {\n        if (marked[linkedNodeId]) continue;\n        leafCounts[id] += recursiveAnalyze(linkedNodeId, depth + 1);\n      }\n      if (leafCounts[id] === 0) leafCounts[id] = 1;\n      return leafCounts[id];\n    };\n    recursiveAnalyze(root, 0);\n    const hGap = rect.width / leafCounts[root];\n    const vGap = rect.height / maxDepth;\n    marked = {};\n    const recursivePosition = (node, h, v) => {\n      marked[node.id] = true;\n      node.x = rect.left + (h + leafCounts[node.id] / 2) * hGap;\n      node.y = rect.top + v * vGap;\n      const linkedNodes = this.findLinkedNodes(node.id, false);\n      if (sorted) linkedNodes.sort((a, b) => a.id - b.id);\n      for (const linkedNode of linkedNodes) {\n        if (marked[linkedNode.id]) continue;\n        recursivePosition(linkedNode, h, v + 1);\n        h += leafCounts[linkedNode.id];\n      }\n    };\n    const rootNode = this.findNode(root);\n    recursivePosition(rootNode, 0, 0);\n  }\n  layoutRandom() {\n    this.callLayout = {\n      method: this.layoutRandom,\n      args: arguments\n    };\n    const rect = this.getRect();\n    const placedNodes = [];\n    for (const node of this.nodes) {\n      do {\n        node.x = rect.left + Math.random() * rect.width;\n        node.y = rect.top + Math.random() * rect.height;\n      } while (placedNodes.find(placedNode => distance(node, placedNode) < 48));\n      placedNodes.push(node);\n    }\n  }\n  visit(target, source, weight) {\n    this.visitOrLeave(true, target, source, weight);\n  }\n  leave(target, source, weight) {\n    this.visitOrLeave(false, target, source, weight);\n  }\n  visitOrLeave(visit, target, source = null, weight) {\n    const edge = this.findEdge(source, target);\n    if (edge) edge.visitedCount += visit ? 1 : -1;\n    const node = this.findNode(target);\n    if (weight !== undefined) node.weight = weight;\n    node.visitedCount += visit ? 1 : -1;\n    if (this.logTracer) {\n      this.logTracer.println(visit ? (source || '') + ' -> ' + target : (source || '') + ' <- ' + target);\n    }\n  }\n  select(target, source) {\n    this.selectOrDeselect(true, target, source);\n  }\n  deselect(target, source) {\n    this.selectOrDeselect(false, target, source);\n  }\n  selectOrDeselect(select, target, source = null) {\n    const edge = this.findEdge(source, target);\n    if (edge) edge.selectedCount += select ? 1 : -1;\n    const node = this.findNode(target);\n    node.selectedCount += select ? 1 : -1;\n    if (this.logTracer) {\n      this.logTracer.println(select ? (source || '') + ' => ' + target : (source || '') + ' <= ' + target);\n    }\n  }\n  log(key) {\n    this.logTracer = key ? this.getObject(key) : null;\n  }\n}\nexport default GraphTracer;","map":{"version":3,"names":["Tracer","distance","GraphRenderer","GraphTracer","getRendererClass","init","dimensions","baseWidth","baseHeight","padding","nodeRadius","arrowGap","nodeWeightGap","edgeWeightGap","isDirected","isWeighted","callLayout","method","layoutCircle","args","logTracer","set","array2d","nodes","edges","i","length","addNode","j","value","addEdge","layout","directed","weighted","id","weight","x","y","visitedCount","selectedCount","findNode","push","updateNode","node","update","Object","keys","forEach","key","undefined","assign","removeNode","index","indexOf","splice","source","target","findEdge","updateEdge","edge","removeEdge","find","findLinkedEdges","filter","findLinkedNodeIds","map","findLinkedNodes","ids","getRect","left","top","right","bottom","width","height","apply","arguments","rect","unitAngle","Math","PI","angle","cos","sin","layoutTree","root","sorted","maxDepth","leafCounts","marked","recursiveAnalyze","depth","linkedNodeIds","linkedNodeId","hGap","vGap","recursivePosition","h","v","linkedNodes","sort","a","b","linkedNode","rootNode","layoutRandom","placedNodes","random","placedNode","visit","visitOrLeave","leave","println","select","selectOrDeselect","deselect","log","getObject"],"sources":["/home/om-bade/Downloads/AlgoLab-main/visualizer/src/core/tracers/GraphTracer.js"],"sourcesContent":["import { Tracer } from 'core/tracers';\nimport { distance } from 'common/util';\nimport { GraphRenderer } from 'core/renderers';\n\nclass GraphTracer extends Tracer {\n  getRendererClass() {\n    return GraphRenderer;\n  }\n\n  init() {\n    super.init();\n    this.dimensions = {\n      baseWidth: 320,\n      baseHeight: 320,\n      padding: 32,\n      nodeRadius: 12,\n      arrowGap: 4,\n      nodeWeightGap: 4,\n      edgeWeightGap: 4,\n    };\n    this.isDirected = true;\n    this.isWeighted = false;\n    this.callLayout = { method: this.layoutCircle, args: [] };\n    this.logTracer = null;\n  }\n\n  set(array2d = []) {\n    this.nodes = [];\n    this.edges = [];\n    for (let i = 0; i < array2d.length; i++) {\n      this.addNode(i);\n      for (let j = 0; j < array2d.length; j++) {\n        const value = array2d[i][j];\n        if (value) {\n          this.addEdge(i, j, this.isWeighted ? value : null);\n        }\n      }\n    }\n    this.layout();\n    super.set();\n  }\n\n  directed(isDirected = true) {\n    this.isDirected = isDirected;\n  }\n\n  weighted(isWeighted = true) {\n    this.isWeighted = isWeighted;\n  }\n\n  addNode(id, weight = null, x = 0, y = 0, visitedCount = 0, selectedCount = 0) {\n    if (this.findNode(id)) return;\n    this.nodes.push({ id, weight, x, y, visitedCount, selectedCount });\n    this.layout();\n  }\n\n  updateNode(id, weight, x, y, visitedCount, selectedCount) {\n    const node = this.findNode(id);\n    const update = { weight, x, y, visitedCount, selectedCount };\n    Object.keys(update).forEach(key => {\n      if (update[key] === undefined) delete update[key];\n    });\n    Object.assign(node, update);\n  }\n\n  removeNode(id) {\n    const node = this.findNode(id);\n    if (!node) return;\n    const index = this.nodes.indexOf(node);\n    this.nodes.splice(index, 1);\n    this.layout();\n  }\n\n  addEdge(source, target, weight = null, visitedCount = 0, selectedCount = 0) {\n    if (this.findEdge(source, target)) return;\n    this.edges.push({ source, target, weight, visitedCount, selectedCount });\n    this.layout();\n  }\n\n  updateEdge(source, target, weight, visitedCount, selectedCount) {\n    const edge = this.findEdge(source, target);\n    const update = { weight, visitedCount, selectedCount };\n    Object.keys(update).forEach(key => {\n      if (update[key] === undefined) delete update[key];\n    });\n    Object.assign(edge, update);\n  }\n\n  removeEdge(source, target) {\n    const edge = this.findEdge(source, target);\n    if (!edge) return;\n    const index = this.edges.indexOf(edge);\n    this.edges.splice(index, 1);\n    this.layout();\n  }\n\n  findNode(id) {\n    return this.nodes.find(node => node.id === id);\n  }\n\n  findEdge(source, target, isDirected = this.isDirected) {\n    if (isDirected) {\n      return this.edges.find(edge => edge.source === source && edge.target === target);\n    } else {\n      return this.edges.find(edge =>\n        (edge.source === source && edge.target === target) ||\n        (edge.source === target && edge.target === source));\n    }\n  }\n\n  findLinkedEdges(source, isDirected = this.isDirected) {\n    if (isDirected) {\n      return this.edges.filter(edge => edge.source === source);\n    } else {\n      return this.edges.filter(edge => edge.source === source || edge.target === source);\n    }\n  }\n\n  findLinkedNodeIds(source, isDirected = this.isDirected) {\n    const edges = this.findLinkedEdges(source, isDirected);\n    return edges.map(edge => edge.source === source ? edge.target : edge.source);\n  }\n\n  findLinkedNodes(source, isDirected = this.isDirected) {\n    const ids = this.findLinkedNodeIds(source, isDirected);\n    return ids.map(id => this.findNode(id));\n  }\n\n  getRect() {\n    const { baseWidth, baseHeight, padding } = this.dimensions;\n    const left = -baseWidth / 2 + padding;\n    const top = -baseHeight / 2 + padding;\n    const right = baseWidth / 2 - padding;\n    const bottom = baseHeight / 2 - padding;\n    const width = right - left;\n    const height = bottom - top;\n    return { left, top, right, bottom, width, height };\n  }\n\n  layout() {\n    const { method, args } = this.callLayout;\n    method.apply(this, args);\n  }\n\n  layoutCircle() {\n    this.callLayout = { method: this.layoutCircle, args: arguments };\n    const rect = this.getRect();\n    const unitAngle = 2 * Math.PI / this.nodes.length;\n    let angle = -Math.PI / 2;\n    for (const node of this.nodes) {\n      const x = Math.cos(angle) * rect.width / 2;\n      const y = Math.sin(angle) * rect.height / 2;\n      node.x = x;\n      node.y = y;\n      angle += unitAngle;\n    }\n  }\n\n  layoutTree(root = 0, sorted = false) {\n    this.callLayout = { method: this.layoutTree, args: arguments };\n    const rect = this.getRect();\n\n    if (this.nodes.length === 1) {\n      const [node] = this.nodes;\n      node.x = (rect.left + rect.right) / 2;\n      node.y = (rect.top + rect.bottom) / 2;\n      return;\n    }\n\n    let maxDepth = 0;\n    const leafCounts = {};\n    let marked = {};\n    const recursiveAnalyze = (id, depth) => {\n      marked[id] = true;\n      leafCounts[id] = 0;\n      if (maxDepth < depth) maxDepth = depth;\n      const linkedNodeIds = this.findLinkedNodeIds(id, false);\n      for (const linkedNodeId of linkedNodeIds) {\n        if (marked[linkedNodeId]) continue;\n        leafCounts[id] += recursiveAnalyze(linkedNodeId, depth + 1);\n      }\n      if (leafCounts[id] === 0) leafCounts[id] = 1;\n      return leafCounts[id];\n    };\n    recursiveAnalyze(root, 0);\n\n    const hGap = rect.width / leafCounts[root];\n    const vGap = rect.height / maxDepth;\n    marked = {};\n    const recursivePosition = (node, h, v) => {\n      marked[node.id] = true;\n      node.x = rect.left + (h + leafCounts[node.id] / 2) * hGap;\n      node.y = rect.top + v * vGap;\n      const linkedNodes = this.findLinkedNodes(node.id, false);\n      if (sorted) linkedNodes.sort((a, b) => a.id - b.id);\n      for (const linkedNode of linkedNodes) {\n        if (marked[linkedNode.id]) continue;\n        recursivePosition(linkedNode, h, v + 1);\n        h += leafCounts[linkedNode.id];\n      }\n    };\n    const rootNode = this.findNode(root);\n    recursivePosition(rootNode, 0, 0);\n  }\n\n  layoutRandom() {\n    this.callLayout = { method: this.layoutRandom, args: arguments };\n    const rect = this.getRect();\n    const placedNodes = [];\n    for (const node of this.nodes) {\n      do {\n        node.x = rect.left + Math.random() * rect.width;\n        node.y = rect.top + Math.random() * rect.height;\n      } while (placedNodes.find(placedNode => distance(node, placedNode) < 48));\n      placedNodes.push(node);\n    }\n  }\n\n  visit(target, source, weight) {\n    this.visitOrLeave(true, target, source, weight);\n  }\n\n  leave(target, source, weight) {\n    this.visitOrLeave(false, target, source, weight);\n  }\n\n  visitOrLeave(visit, target, source = null, weight) {\n    const edge = this.findEdge(source, target);\n    if (edge) edge.visitedCount += visit ? 1 : -1;\n    const node = this.findNode(target);\n    if (weight !== undefined) node.weight = weight;\n    node.visitedCount += visit ? 1 : -1;\n    if (this.logTracer) {\n      this.logTracer.println(visit ? (source || '') + ' -> ' + target : (source || '') + ' <- ' + target);\n    }\n  }\n\n  select(target, source) {\n    this.selectOrDeselect(true, target, source);\n  }\n\n  deselect(target, source) {\n    this.selectOrDeselect(false, target, source);\n  }\n\n  selectOrDeselect(select, target, source = null) {\n    const edge = this.findEdge(source, target);\n    if (edge) edge.selectedCount += select ? 1 : -1;\n    const node = this.findNode(target);\n    node.selectedCount += select ? 1 : -1;\n    if (this.logTracer) {\n      this.logTracer.println(select ? (source || '') + ' => ' + target : (source || '') + ' <= ' + target);\n    }\n  }\n\n  log(key) {\n    this.logTracer = key ? this.getObject(key) : null;\n  }\n}\n\nexport default GraphTracer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}